// Code generated by pggen. DO NOT EDIT.

package db

import (
	"context"
	"fmt"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const uilistRecentRunsSQL = `SELECT runs.*, tests.name as test_name, tests.labels, test_run_configs.container_image, test_run_configs.command, test_run_configs.args, test_run_configs.env, test_run_configs.created_at, runners.name AS runner_name
FROM runs
JOIN test_run_configs ON runs.test_run_config_id = test_run_configs.id
JOIN runners ON runs.runner_id = runners.id
JOIN tests on runs.test_id = tests.id
ORDER BY runs.started_at DESC
LIMIT $1;`

type UIListRecentRunsRow struct {
	ID              string             `json:"id"`
	TestID          string             `json:"test_id"`
	TestRunConfigID string             `json:"test_run_config_id"`
	RunnerID        string             `json:"runner_id"`
	Result          RunResult          `json:"result"`
	Logs            pgtype.JSONB       `json:"logs"`
	ScheduledAt     pgtype.Timestamptz `json:"scheduled_at"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	FinishedAt      pgtype.Timestamptz `json:"finished_at"`
	TestName        string             `json:"test_name"`
	Labels          pgtype.JSONB       `json:"labels"`
	ContainerImage  string             `json:"container_image"`
	Command         string             `json:"command"`
	Args            []string           `json:"args"`
	Env             pgtype.JSONB       `json:"env"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	RunnerName      string             `json:"runner_name"`
}

// UIListRecentRuns implements Querier.UIListRecentRuns.
func (q *DBQuerier) UIListRecentRuns(ctx context.Context, limit int) ([]UIListRecentRunsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UIListRecentRuns")
	rows, err := q.conn.Query(ctx, uilistRecentRunsSQL, limit)
	if err != nil {
		return nil, fmt.Errorf("query UIListRecentRuns: %w", err)
	}
	defer rows.Close()
	items := []UIListRecentRunsRow{}
	for rows.Next() {
		var item UIListRecentRunsRow
		if err := rows.Scan(&item.ID, &item.TestID, &item.TestRunConfigID, &item.RunnerID, &item.Result, &item.Logs, &item.ScheduledAt, &item.StartedAt, &item.FinishedAt, &item.TestName, &item.Labels, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.CreatedAt, &item.RunnerName); err != nil {
			return nil, fmt.Errorf("scan UIListRecentRuns row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close UIListRecentRuns rows: %w", err)
	}
	return items, err
}

// UIListRecentRunsBatch implements Querier.UIListRecentRunsBatch.
func (q *DBQuerier) UIListRecentRunsBatch(batch genericBatch, limit int) {
	batch.Queue(uilistRecentRunsSQL, limit)
}

// UIListRecentRunsScan implements Querier.UIListRecentRunsScan.
func (q *DBQuerier) UIListRecentRunsScan(results pgx.BatchResults) ([]UIListRecentRunsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query UIListRecentRunsBatch: %w", err)
	}
	defer rows.Close()
	items := []UIListRecentRunsRow{}
	for rows.Next() {
		var item UIListRecentRunsRow
		if err := rows.Scan(&item.ID, &item.TestID, &item.TestRunConfigID, &item.RunnerID, &item.Result, &item.Logs, &item.ScheduledAt, &item.StartedAt, &item.FinishedAt, &item.TestName, &item.Labels, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.CreatedAt, &item.RunnerName); err != nil {
			return nil, fmt.Errorf("scan UIListRecentRunsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close UIListRecentRunsBatch rows: %w", err)
	}
	return items, err
}

const uitestsByLabelsSQL = `SELECT labels, array_agg(tests.*) AS tests FROM tests WHERE labels IN (SELECT DISTINCT(labels) FROM tests) GROUP BY labels;`

type UITestsByLabelsRow struct {
	Labels pgtype.JSONB `json:"labels"`
	Tests  []Tests      `json:"tests"`
}

// UITestsByLabels implements Querier.UITestsByLabels.
func (q *DBQuerier) UITestsByLabels(ctx context.Context) ([]UITestsByLabelsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UITestsByLabels")
	rows, err := q.conn.Query(ctx, uitestsByLabelsSQL)
	if err != nil {
		return nil, fmt.Errorf("query UITestsByLabels: %w", err)
	}
	defer rows.Close()
	items := []UITestsByLabelsRow{}
	testsArray := q.types.newTestsArray()
	for rows.Next() {
		var item UITestsByLabelsRow
		if err := rows.Scan(&item.Labels, testsArray); err != nil {
			return nil, fmt.Errorf("scan UITestsByLabels row: %w", err)
		}
		if err := testsArray.AssignTo(&item.Tests); err != nil {
			return nil, fmt.Errorf("assign UITestsByLabels row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close UITestsByLabels rows: %w", err)
	}
	return items, err
}

// UITestsByLabelsBatch implements Querier.UITestsByLabelsBatch.
func (q *DBQuerier) UITestsByLabelsBatch(batch genericBatch) {
	batch.Queue(uitestsByLabelsSQL)
}

// UITestsByLabelsScan implements Querier.UITestsByLabelsScan.
func (q *DBQuerier) UITestsByLabelsScan(results pgx.BatchResults) ([]UITestsByLabelsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query UITestsByLabelsBatch: %w", err)
	}
	defer rows.Close()
	items := []UITestsByLabelsRow{}
	testsArray := q.types.newTestsArray()
	for rows.Next() {
		var item UITestsByLabelsRow
		if err := rows.Scan(&item.Labels, testsArray); err != nil {
			return nil, fmt.Errorf("scan UITestsByLabelsBatch row: %w", err)
		}
		if err := testsArray.AssignTo(&item.Tests); err != nil {
			return nil, fmt.Errorf("assign UITestsByLabels row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close UITestsByLabelsBatch rows: %w", err)
	}
	return items, err
}

const uitestResultsSQL = `SELECT test_id,array_agg(result) AS results FROM runs where test_id is not null GROUP BY test_id;`

type UITestResultsRow struct {
	TestID  string      `json:"test_id"`
	Results []RunResult `json:"results"`
}

// UITestResults implements Querier.UITestResults.
func (q *DBQuerier) UITestResults(ctx context.Context) ([]UITestResultsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UITestResults")
	rows, err := q.conn.Query(ctx, uitestResultsSQL)
	if err != nil {
		return nil, fmt.Errorf("query UITestResults: %w", err)
	}
	defer rows.Close()
	items := []UITestResultsRow{}
	resultsArray := q.types.newRunResultArray()
	for rows.Next() {
		var item UITestResultsRow
		if err := rows.Scan(&item.TestID, resultsArray); err != nil {
			return nil, fmt.Errorf("scan UITestResults row: %w", err)
		}
		if err := resultsArray.AssignTo(&item.Results); err != nil {
			return nil, fmt.Errorf("assign UITestResults row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close UITestResults rows: %w", err)
	}
	return items, err
}

// UITestResultsBatch implements Querier.UITestResultsBatch.
func (q *DBQuerier) UITestResultsBatch(batch genericBatch) {
	batch.Queue(uitestResultsSQL)
}

// UITestResultsScan implements Querier.UITestResultsScan.
func (q *DBQuerier) UITestResultsScan(results pgx.BatchResults) ([]UITestResultsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query UITestResultsBatch: %w", err)
	}
	defer rows.Close()
	items := []UITestResultsRow{}
	resultsArray := q.types.newRunResultArray()
	for rows.Next() {
		var item UITestResultsRow
		if err := rows.Scan(&item.TestID, resultsArray); err != nil {
			return nil, fmt.Errorf("scan UITestResultsBatch row: %w", err)
		}
		if err := resultsArray.AssignTo(&item.Results); err != nil {
			return nil, fmt.Errorf("assign UITestResults row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close UITestResultsBatch rows: %w", err)
	}
	return items, err
}
