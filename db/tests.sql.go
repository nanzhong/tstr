// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: tests.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const getTest = `-- name: GetTest :one
SELECT id, name, run_config, labels, cron_schedule, next_run_at, registered_at, updated_at
FROM tests
WHERE tests.id = $1
`

func (q *Queries) GetTest(ctx context.Context, db DBTX, id uuid.UUID) (Test, error) {
	row := db.QueryRow(ctx, getTest, id)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RunConfig,
		&i.Labels,
		&i.CronSchedule,
		&i.NextRunAt,
		&i.RegisteredAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTests = `-- name: ListTests :many
SELECT id, name, run_config, labels, cron_schedule, next_run_at, registered_at, updated_at
FROM tests
ORDER BY tests.name ASC
`

func (q *Queries) ListTests(ctx context.Context, db DBTX) ([]Test, error) {
	rows, err := db.Query(ctx, listTests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RunConfig,
			&i.Labels,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestsIDsMatchingLabelKeys = `-- name: ListTestsIDsMatchingLabelKeys :many
SELECT tests.id, tests.labels
FROM tests
WHERE
  tests.labels ?& COALESCE($1::varchar[], '{}') AND
  NOT tests.labels ?| COALESCE($2::varchar[], '{}')::varchar[]
`

type ListTestsIDsMatchingLabelKeysParams struct {
	IncludeLabelKeys []string
	FilterLabelKeys  []string
}

type ListTestsIDsMatchingLabelKeysRow struct {
	ID     uuid.UUID
	Labels pgtype.JSONB
}

func (q *Queries) ListTestsIDsMatchingLabelKeys(ctx context.Context, db DBTX, arg ListTestsIDsMatchingLabelKeysParams) ([]ListTestsIDsMatchingLabelKeysRow, error) {
	rows, err := db.Query(ctx, listTestsIDsMatchingLabelKeys, arg.IncludeLabelKeys, arg.FilterLabelKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTestsIDsMatchingLabelKeysRow
	for rows.Next() {
		var i ListTestsIDsMatchingLabelKeysRow
		if err := rows.Scan(&i.ID, &i.Labels); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestsToSchedule = `-- name: ListTestsToSchedule :many
SELECT tests.id, name, run_config, tests.labels, cron_schedule, next_run_at, registered_at, updated_at, runs.id, test_id, test_run_config, runs.labels, runner_id, result, logs, result_data, scheduled_at, started_at, finished_at
FROM tests
LEFT JOIN runs
ON runs.test_id = tests.id AND runs.result = 'unknown' AND runs.started_at IS NULL
WHERE tests.next_run_at < CURRENT_TIMESTAMP AND runs.id IS NULL
FOR UPDATE OF tests SKIP LOCKED
`

type ListTestsToScheduleRow struct {
	ID            uuid.UUID
	Name          string
	RunConfig     pgtype.JSONB
	Labels        pgtype.JSONB
	CronSchedule  sql.NullString
	NextRunAt     sql.NullTime
	RegisteredAt  sql.NullTime
	UpdatedAt     sql.NullTime
	ID_2          uuid.NullUUID
	TestID        uuid.NullUUID
	TestRunConfig pgtype.JSONB
	Labels_2      pgtype.JSONB
	RunnerID      uuid.NullUUID
	Result        NullRunResult
	Logs          pgtype.JSONB
	ResultData    pgtype.JSONB
	ScheduledAt   sql.NullTime
	StartedAt     sql.NullTime
	FinishedAt    sql.NullTime
}

func (q *Queries) ListTestsToSchedule(ctx context.Context, db DBTX) ([]ListTestsToScheduleRow, error) {
	rows, err := db.Query(ctx, listTestsToSchedule)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTestsToScheduleRow
	for rows.Next() {
		var i ListTestsToScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RunConfig,
			&i.Labels,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.TestID,
			&i.TestRunConfig,
			&i.Labels_2,
			&i.RunnerID,
			&i.Result,
			&i.Logs,
			&i.ResultData,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTests = `-- name: QueryTests :many
SELECT id, name, run_config, labels, cron_schedule, next_run_at, registered_at, updated_at
FROM tests
WHERE
  ($1::uuid[] IS NULL OR tests.id = ANY ($1::uuid[])) AND
  ($2::uuid[] IS NULL OR tests.id = ANY (
    SELECT tests.id
    FROM test_suites
    JOIN tests
    ON tests.labels @> test_suites.labels
    WHERE test_suites.id = ANY ($2::uuid[])
    )) AND
  ($3::jsonb IS NULL OR tests.labels @> $3::jsonb)
ORDER BY tests.name ASC
`

type QueryTestsParams struct {
	Ids          []uuid.UUID
	TestSuiteIds []uuid.UUID
	Labels       pgtype.JSONB
}

func (q *Queries) QueryTests(ctx context.Context, db DBTX, arg QueryTestsParams) ([]Test, error) {
	rows, err := db.Query(ctx, queryTests, arg.Ids, arg.TestSuiteIds, arg.Labels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RunConfig,
			&i.Labels,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerTest = `-- name: RegisterTest :one
INSERT INTO tests (name, labels, run_config, cron_schedule, next_run_at)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING id, name, run_config, labels, cron_schedule, next_run_at, registered_at, updated_at
`

type RegisterTestParams struct {
	Name         string
	Labels       pgtype.JSONB
	RunConfig    pgtype.JSONB
	CronSchedule sql.NullString
	NextRunAt    sql.NullTime
}

func (q *Queries) RegisterTest(ctx context.Context, db DBTX, arg RegisterTestParams) (Test, error) {
	row := db.QueryRow(ctx, registerTest,
		arg.Name,
		arg.Labels,
		arg.RunConfig,
		arg.CronSchedule,
		arg.NextRunAt,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RunConfig,
		&i.Labels,
		&i.CronSchedule,
		&i.NextRunAt,
		&i.RegisteredAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTest = `-- name: UpdateTest :exec
UPDATE tests
SET
  name = $1::varchar,
  labels = $2::jsonb,
  run_config = $3::jsonb,
  cron_schedule = $4::varchar,
  next_run_at = $5::timestamptz,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $6::uuid
`

type UpdateTestParams struct {
	Name         string
	Labels       pgtype.JSONB
	RunConfig    pgtype.JSONB
	CronSchedule sql.NullString
	NextRunAt    sql.NullTime
	ID           uuid.UUID
}

func (q *Queries) UpdateTest(ctx context.Context, db DBTX, arg UpdateTestParams) error {
	_, err := db.Exec(ctx, updateTest,
		arg.Name,
		arg.Labels,
		arg.RunConfig,
		arg.CronSchedule,
		arg.NextRunAt,
		arg.ID,
	)
	return err
}
