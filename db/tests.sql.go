// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: tests.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const archiveTest = `-- name: ArchiveTest :exec
UPDATE tests
SET archived_at = CURRENT_TIMESTAMP
WHERE id = $1::uuid
`

func (q *Queries) ArchiveTest(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, archiveTest, id)
	return err
}

const createTestRunConfig = `-- name: CreateTestRunConfig :one
INSERT INTO test_run_configs (container_image, command, args, env)
VALUES (
  $1::varchar,
  $2::varchar,
  $3::varchar[],
  $4::jsonb
)
RETURNING id, test_id, container_image, command, args, env, created_at
`

type CreateTestRunConfigParams struct {
	ContainerImage string
	Command        string
	Args           []string
	Env            pgtype.JSONB
}

func (q *Queries) CreateTestRunConfig(ctx context.Context, db DBTX, arg CreateTestRunConfigParams) (TestRunConfig, error) {
	row := db.QueryRow(ctx, createTestRunConfig,
		arg.ContainerImage,
		arg.Command,
		arg.Args,
		arg.Env,
	)
	var i TestRunConfig
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.ContainerImage,
		&i.Command,
		&i.Args,
		&i.Env,
		&i.CreatedAt,
	)
	return i, err
}

const getTest = `-- name: GetTest :one
SELECT tests.id, tests.name, tests.labels, tests.cron_schedule, tests.next_run_at, tests.registered_at, tests.updated_at, tests.archived_at, latest_configs.id AS test_run_config_id, latest_configs.container_image, latest_configs.command, latest_configs.args, latest_configs.env, latest_configs.created_at
FROM tests
JOIN test_run_configs AS latest_configs
ON tests.id = latest_configs.test_id
LEFT JOIN test_run_configs
ON test_run_configs.test_id = latest_configs.test_id AND latest_configs.created_at > test_run_configs.created_at
WHERE tests.id = $1::uuid
ORDER BY test_run_configs.created_at DESC
LIMIT 1
`

type GetTestRow struct {
	ID              uuid.UUID
	Name            string
	Labels          pgtype.JSONB
	CronSchedule    sql.NullString
	NextRunAt       sql.NullTime
	RegisteredAt    sql.NullTime
	UpdatedAt       sql.NullTime
	ArchivedAt      sql.NullTime
	TestRunConfigID uuid.NullUUID
	ContainerImage  sql.NullString
	Command         sql.NullString
	Args            []string
	Env             pgtype.JSONB
	CreatedAt       sql.NullTime
}

func (q *Queries) GetTest(ctx context.Context, db DBTX, id uuid.UUID) (GetTestRow, error) {
	row := db.QueryRow(ctx, getTest, id)
	var i GetTestRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Labels,
		&i.CronSchedule,
		&i.NextRunAt,
		&i.RegisteredAt,
		&i.UpdatedAt,
		&i.ArchivedAt,
		&i.TestRunConfigID,
		&i.ContainerImage,
		&i.Command,
		&i.Args,
		&i.Env,
		&i.CreatedAt,
	)
	return i, err
}

const listTests = `-- name: ListTests :many
SELECT tests.id, tests.name, tests.labels, tests.cron_schedule, tests.next_run_at, tests.registered_at, tests.updated_at, tests.archived_at, latest_configs.id AS test_run_config_id, latest_configs.container_image, latest_configs.command, latest_configs.args, latest_configs.env, latest_configs.created_at
FROM tests
JOIN test_run_configs AS latest_configs
ON tests.id = latest_configs.test_id
LEFT JOIN test_run_configs
ON test_run_configs.test_id = latest_configs.test_id AND latest_configs.created_at > test_run_configs.created_at
WHERE test_run_configs IS NULL AND tests.labels @> $1::jsonb
ORDER BY tests.name ASC
`

type ListTestsRow struct {
	ID              uuid.UUID
	Name            string
	Labels          pgtype.JSONB
	CronSchedule    sql.NullString
	NextRunAt       sql.NullTime
	RegisteredAt    sql.NullTime
	UpdatedAt       sql.NullTime
	ArchivedAt      sql.NullTime
	TestRunConfigID uuid.NullUUID
	ContainerImage  sql.NullString
	Command         sql.NullString
	Args            []string
	Env             pgtype.JSONB
	CreatedAt       sql.NullTime
}

func (q *Queries) ListTests(ctx context.Context, db DBTX, labels pgtype.JSONB) ([]ListTestsRow, error) {
	rows, err := db.Query(ctx, listTests, labels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTestsRow
	for rows.Next() {
		var i ListTestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Labels,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
			&i.ArchivedAt,
			&i.TestRunConfigID,
			&i.ContainerImage,
			&i.Command,
			&i.Args,
			&i.Env,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestsIDsMatchingLabelKeys = `-- name: ListTestsIDsMatchingLabelKeys :many
SELECT tests.id, tests.labels
FROM tests
WHERE
  tests.labels ?& COALESCE($1::varchar[], '{}') AND
  NOT tests.labels ?| COALESCE($2::varchar[], '{}')::varchar[]
`

type ListTestsIDsMatchingLabelKeysParams struct {
	IncludeLabelKeys []string
	FilterLabelKeys  []string
}

type ListTestsIDsMatchingLabelKeysRow struct {
	ID     uuid.UUID
	Labels pgtype.JSONB
}

func (q *Queries) ListTestsIDsMatchingLabelKeys(ctx context.Context, db DBTX, arg ListTestsIDsMatchingLabelKeysParams) ([]ListTestsIDsMatchingLabelKeysRow, error) {
	rows, err := db.Query(ctx, listTestsIDsMatchingLabelKeys, arg.IncludeLabelKeys, arg.FilterLabelKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTestsIDsMatchingLabelKeysRow
	for rows.Next() {
		var i ListTestsIDsMatchingLabelKeysRow
		if err := rows.Scan(&i.ID, &i.Labels); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestsToSchedule = `-- name: ListTestsToSchedule :many
SELECT tests.id, tests.name, tests.labels, tests.cron_schedule, tests.next_run_at, tests.registered_at, tests.updated_at, tests.archived_at, latest_configs.id AS test_run_config_id, latest_configs.container_image, latest_configs.command, latest_configs.args, latest_configs.env, latest_configs.created_at
FROM tests
JOIN test_run_configs AS latest_configs
ON tests.id = latest_configs.test_id
LEFT JOIN test_run_configs
ON test_run_configs.test_id = latest_configs.test_id AND latest_configs.created_at > test_run_configs.created_at
LEFT JOIN runs
ON runs.test_id = tests.id AND runs.result = 'unknown' AND runs.started_at IS NULL
WHERE next_run_at < CURRENT_TIMESTAMP AND runs.id IS NULL
FOR UPDATE OF tests SKIP LOCKED
`

type ListTestsToScheduleRow struct {
	ID              uuid.UUID
	Name            string
	Labels          pgtype.JSONB
	CronSchedule    sql.NullString
	NextRunAt       sql.NullTime
	RegisteredAt    sql.NullTime
	UpdatedAt       sql.NullTime
	ArchivedAt      sql.NullTime
	TestRunConfigID uuid.NullUUID
	ContainerImage  sql.NullString
	Command         sql.NullString
	Args            []string
	Env             pgtype.JSONB
	CreatedAt       sql.NullTime
}

func (q *Queries) ListTestsToSchedule(ctx context.Context, db DBTX) ([]ListTestsToScheduleRow, error) {
	rows, err := db.Query(ctx, listTestsToSchedule)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTestsToScheduleRow
	for rows.Next() {
		var i ListTestsToScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Labels,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
			&i.ArchivedAt,
			&i.TestRunConfigID,
			&i.ContainerImage,
			&i.Command,
			&i.Args,
			&i.Env,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTests = `-- name: QueryTests :many
SELECT tests.id, tests.name, tests.labels, tests.cron_schedule, tests.next_run_at, tests.registered_at, tests.updated_at, tests.archived_at, latest_configs.id AS test_run_config_id, latest_configs.container_image, latest_configs.command, latest_configs.args, latest_configs.env, latest_configs.created_at
FROM tests
JOIN test_run_configs AS latest_configs
ON tests.id = latest_configs.test_id
LEFT JOIN test_run_configs
ON test_run_configs.test_id = latest_configs.test_id AND latest_configs.created_at > test_run_configs.created_at
WHERE
  ($1::uuid[] IS NULL OR tests.id = ANY ($1::uuid[])) AND
  ($2::uuid[] IS NULL OR tests.id = ANY (
    SELECT tests.id
    FROM test_suites
    JOIN tests
    ON tests.labels @> test_suites.labels
    WHERE test_suites.id = ANY ($2::uuid[])
    )) AND
  ($3::jsonb IS NULL OR tests.labels @> $3::jsonb)
ORDER BY tests.name ASC
`

type QueryTestsParams struct {
	Ids          []uuid.UUID
	TestSuiteIds []uuid.UUID
	Labels       pgtype.JSONB
}

type QueryTestsRow struct {
	ID              uuid.UUID
	Name            string
	Labels          pgtype.JSONB
	CronSchedule    sql.NullString
	NextRunAt       sql.NullTime
	RegisteredAt    sql.NullTime
	UpdatedAt       sql.NullTime
	ArchivedAt      sql.NullTime
	TestRunConfigID uuid.NullUUID
	ContainerImage  sql.NullString
	Command         sql.NullString
	Args            []string
	Env             pgtype.JSONB
	CreatedAt       sql.NullTime
}

func (q *Queries) QueryTests(ctx context.Context, db DBTX, arg QueryTestsParams) ([]QueryTestsRow, error) {
	rows, err := db.Query(ctx, queryTests, arg.Ids, arg.TestSuiteIds, arg.Labels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryTestsRow
	for rows.Next() {
		var i QueryTestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Labels,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
			&i.ArchivedAt,
			&i.TestRunConfigID,
			&i.ContainerImage,
			&i.Command,
			&i.Args,
			&i.Env,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerTest = `-- name: RegisterTest :one
WITH data (name, labels, cron_schedule, next_run_at, container_image, command, args, env) AS (
  VALUES (
    $1::varchar,
    $2::jsonb,
    $3::varchar,
    $4::timestamptz,
    $5::varchar,
    $6::varchar,
    $7::varchar[],
    $8::jsonb
  )
), test AS (
  INSERT INTO tests (name, labels, cron_schedule, next_run_at)
  SELECT name, labels, cron_schedule, next_run_at
  FROM data
  RETURNING id, name, labels, cron_schedule, next_run_at, registered_at, updated_at
), test_run_config AS (
  INSERT INTO test_run_configs (test_id, container_image, command, args, env)
  SELECT test.id, container_image, command, args, env
  FROM data, test
  RETURNING id AS test_run_config_id, container_image, command, args, env, created_at AS test_run_config_created_at
)
SELECT id, name, labels, cron_schedule, next_run_at, registered_at, updated_at, test_run_config_id, container_image, command, args, env, test_run_config_created_at FROM test, test_run_config
`

type RegisterTestParams struct {
	Name           string
	Labels         pgtype.JSONB
	CronSchedule   string
	NextRunAt      sql.NullTime
	ContainerImage string
	Command        string
	Args           []string
	Env            pgtype.JSONB
}

type RegisterTestRow struct {
	ID                     uuid.UUID
	Name                   string
	Labels                 pgtype.JSONB
	CronSchedule           sql.NullString
	NextRunAt              sql.NullTime
	RegisteredAt           sql.NullTime
	UpdatedAt              sql.NullTime
	TestRunConfigID        uuid.UUID
	ContainerImage         string
	Command                sql.NullString
	Args                   []string
	Env                    pgtype.JSONB
	TestRunConfigCreatedAt sql.NullTime
}

func (q *Queries) RegisterTest(ctx context.Context, db DBTX, arg RegisterTestParams) (RegisterTestRow, error) {
	row := db.QueryRow(ctx, registerTest,
		arg.Name,
		arg.Labels,
		arg.CronSchedule,
		arg.NextRunAt,
		arg.ContainerImage,
		arg.Command,
		arg.Args,
		arg.Env,
	)
	var i RegisterTestRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Labels,
		&i.CronSchedule,
		&i.NextRunAt,
		&i.RegisteredAt,
		&i.UpdatedAt,
		&i.TestRunConfigID,
		&i.ContainerImage,
		&i.Command,
		&i.Args,
		&i.Env,
		&i.TestRunConfigCreatedAt,
	)
	return i, err
}

const updateTest = `-- name: UpdateTest :exec
UPDATE tests
SET
  name = $1::varchar,
  labels = $2::jsonb,
  cron_schedule = $3::varchar,
  next_run_at = $4::timestamptz,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $5::uuid
`

type UpdateTestParams struct {
	Name         string
	Labels       pgtype.JSONB
	CronSchedule string
	NextRunAt    sql.NullTime
	ID           uuid.UUID
}

func (q *Queries) UpdateTest(ctx context.Context, db DBTX, arg UpdateTestParams) error {
	_, err := db.Exec(ctx, updateTest,
		arg.Name,
		arg.Labels,
		arg.CronSchedule,
		arg.NextRunAt,
		arg.ID,
	)
	return err
}
