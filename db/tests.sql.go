// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: tests.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
)

const deleteTest = `-- name: DeleteTest :execresult
DELETE FROM tests
WHERE id = $1::uuid AND tests.namespace = $2
`

type DeleteTestParams struct {
	ID        uuid.UUID
	Namespace string
}

func (q *Queries) DeleteTest(ctx context.Context, db DBTX, arg DeleteTestParams) (pgconn.CommandTag, error) {
	return db.Exec(ctx, deleteTest, arg.ID, arg.Namespace)
}

const getTest = `-- name: GetTest :one
SELECT id, name, run_config, labels, matrix, cron_schedule, next_run_at, registered_at, updated_at, namespace
FROM tests
WHERE tests.id = $1 AND tests.namespace = $2
`

type GetTestParams struct {
	ID        uuid.UUID
	Namespace string
}

func (q *Queries) GetTest(ctx context.Context, db DBTX, arg GetTestParams) (Test, error) {
	row := db.QueryRow(ctx, getTest, arg.ID, arg.Namespace)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RunConfig,
		&i.Labels,
		&i.Matrix,
		&i.CronSchedule,
		&i.NextRunAt,
		&i.RegisteredAt,
		&i.UpdatedAt,
		&i.Namespace,
	)
	return i, err
}

const listAllNamespaces = `-- name: ListAllNamespaces :many
SELECT DISTINCT(namespace)
FROM tests
`

func (q *Queries) ListAllNamespaces(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.Query(ctx, listAllNamespaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var namespace string
		if err := rows.Scan(&namespace); err != nil {
			return nil, err
		}
		items = append(items, namespace)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTests = `-- name: ListTests :many
SELECT id, name, run_config, labels, matrix, cron_schedule, next_run_at, registered_at, updated_at, namespace
FROM tests
WHERE tests.namespace = $1
ORDER BY tests.name ASC
`

func (q *Queries) ListTests(ctx context.Context, db DBTX, namespace string) ([]Test, error) {
	rows, err := db.Query(ctx, listTests, namespace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RunConfig,
			&i.Labels,
			&i.Matrix,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
			&i.Namespace,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestsToSchedule = `-- name: ListTestsToSchedule :many
SELECT tests.id, tests.name, tests.run_config, tests.labels, tests.matrix, tests.cron_schedule, tests.next_run_at, tests.registered_at, tests.updated_at, tests.namespace
FROM tests
LEFT JOIN runs
ON runs.test_id = tests.id AND runs.result = 'unknown' AND runs.started_at IS NULL
WHERE tests.next_run_at < CURRENT_TIMESTAMP AND runs.id IS NULL
ORDER BY tests.next_run_at ASC
FOR UPDATE OF tests SKIP LOCKED
`

func (q *Queries) ListTestsToSchedule(ctx context.Context, db DBTX) ([]Test, error) {
	rows, err := db.Query(ctx, listTestsToSchedule)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RunConfig,
			&i.Labels,
			&i.Matrix,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
			&i.Namespace,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTests = `-- name: QueryTests :many
SELECT id, name, run_config, labels, matrix, cron_schedule, next_run_at, registered_at, updated_at, namespace
FROM tests
WHERE
  tests.namespace = $1 AND
  ($2::uuid[] IS NULL OR tests.id = ANY ($2::uuid[])) AND
  ($3::jsonb IS NULL OR tests.labels @> $3::jsonb)
ORDER BY tests.name ASC
`

type QueryTestsParams struct {
	Namespace string
	Ids       []uuid.UUID
	Labels    pgtype.JSONB
}

func (q *Queries) QueryTests(ctx context.Context, db DBTX, arg QueryTestsParams) ([]Test, error) {
	rows, err := db.Query(ctx, queryTests, arg.Namespace, arg.Ids, arg.Labels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RunConfig,
			&i.Labels,
			&i.Matrix,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
			&i.Namespace,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerTest = `-- name: RegisterTest :one
INSERT INTO tests (namespace, name, run_config, labels, matrix, cron_schedule, next_run_at)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7
)
RETURNING id, name, run_config, labels, matrix, cron_schedule, next_run_at, registered_at, updated_at, namespace
`

type RegisterTestParams struct {
	Namespace    string
	Name         string
	RunConfig    pgtype.JSONB
	Labels       pgtype.JSONB
	Matrix       pgtype.JSONB
	CronSchedule sql.NullString
	NextRunAt    sql.NullTime
}

func (q *Queries) RegisterTest(ctx context.Context, db DBTX, arg RegisterTestParams) (Test, error) {
	row := db.QueryRow(ctx, registerTest,
		arg.Namespace,
		arg.Name,
		arg.RunConfig,
		arg.Labels,
		arg.Matrix,
		arg.CronSchedule,
		arg.NextRunAt,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RunConfig,
		&i.Labels,
		&i.Matrix,
		&i.CronSchedule,
		&i.NextRunAt,
		&i.RegisteredAt,
		&i.UpdatedAt,
		&i.Namespace,
	)
	return i, err
}

const updateTest = `-- name: UpdateTest :execresult
UPDATE tests
SET
  name = $1::varchar,
  run_config = $2::jsonb,
  labels = $3::jsonb,
  matrix = $4::jsonb,
  cron_schedule = $5::varchar,
  next_run_at = $6::timestamptz,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $7::uuid AND tests.namespace = $8
`

type UpdateTestParams struct {
	Name         string
	RunConfig    pgtype.JSONB
	Labels       pgtype.JSONB
	Matrix       pgtype.JSONB
	CronSchedule sql.NullString
	NextRunAt    sql.NullTime
	ID           uuid.UUID
	Namespace    string
}

func (q *Queries) UpdateTest(ctx context.Context, db DBTX, arg UpdateTestParams) (pgconn.CommandTag, error) {
	return db.Exec(ctx, updateTest,
		arg.Name,
		arg.RunConfig,
		arg.Labels,
		arg.Matrix,
		arg.CronSchedule,
		arg.NextRunAt,
		arg.ID,
		arg.Namespace,
	)
}
