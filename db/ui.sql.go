// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: ui.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const uIListRecentRuns = `-- name: UIListRecentRuns :many
SELECT runs.id, runs.test_id, runs.test_run_config_id, runs.runner_id, runs.result, runs.logs, runs.scheduled_at, runs.started_at, runs.finished_at, tests.name as test_name, tests.labels, test_run_configs.container_image, test_run_configs.command, test_run_configs.args, test_run_configs.env, test_run_configs.created_at, runners.name AS runner_name, (finished_at is NULL)::bool AS is_pending
FROM runs
JOIN test_run_configs ON runs.test_run_config_id = test_run_configs.id
JOIN runners ON runs.runner_id = runners.id
JOIN tests on runs.test_id = tests.id
ORDER BY is_pending, runs.started_at DESC
LIMIT $1
`

type UIListRecentRunsRow struct {
	ID              uuid.UUID
	TestID          uuid.UUID
	TestRunConfigID uuid.UUID
	RunnerID        uuid.NullUUID
	Result          NullRunResult
	Logs            pgtype.JSONB
	ScheduledAt     sql.NullTime
	StartedAt       sql.NullTime
	FinishedAt      sql.NullTime
	TestName        string
	Labels          pgtype.JSONB
	ContainerImage  string
	Command         sql.NullString
	Args            []string
	Env             pgtype.JSONB
	CreatedAt       sql.NullTime
	RunnerName      string
	IsPending       bool
}

func (q *Queries) UIListRecentRuns(ctx context.Context, db DBTX, limit int32) ([]UIListRecentRunsRow, error) {
	rows, err := db.Query(ctx, uIListRecentRuns, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UIListRecentRunsRow
	for rows.Next() {
		var i UIListRecentRunsRow
		if err := rows.Scan(
			&i.ID,
			&i.TestID,
			&i.TestRunConfigID,
			&i.RunnerID,
			&i.Result,
			&i.Logs,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TestName,
			&i.Labels,
			&i.ContainerImage,
			&i.Command,
			&i.Args,
			&i.Env,
			&i.CreatedAt,
			&i.RunnerName,
			&i.IsPending,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uIListTests = `-- name: UIListTests :many
select id, name, labels, cron_schedule, next_run_at, registered_at, updated_at, archived_at from tests
`

func (q *Queries) UIListTests(ctx context.Context, db DBTX) ([]Test, error) {
	rows, err := db.Query(ctx, uIListTests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Labels,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uIRunnerSummary = `-- name: UIRunnerSummary :many
SELECT T.name AS test_name, T.id as test_id, R.id as run_id, R.result, R.finished_at , R.started_at from runs R 
INNER JOIN tests T on T.id = R.test_id 
WHERE runner_id = $1::uuid
ORDER BY R.started_at DESC
LIMIT $2
`

type UIRunnerSummaryParams struct {
	RunnerID uuid.NullUUID
	Limit    int32
}

type UIRunnerSummaryRow struct {
	TestName   string
	TestID     uuid.UUID
	RunID      uuid.UUID
	Result     NullRunResult
	FinishedAt sql.NullTime
	StartedAt  sql.NullTime
}

func (q *Queries) UIRunnerSummary(ctx context.Context, db DBTX, arg UIRunnerSummaryParams) ([]UIRunnerSummaryRow, error) {
	rows, err := db.Query(ctx, uIRunnerSummary, arg.RunnerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UIRunnerSummaryRow
	for rows.Next() {
		var i UIRunnerSummaryRow
		if err := rows.Scan(
			&i.TestName,
			&i.TestID,
			&i.RunID,
			&i.Result,
			&i.FinishedAt,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uIRunsSummary = `-- name: UIRunsSummary :many
SELECT id, test_run_config_id, runner_id, result, scheduled_at, started_at,finished_at
FROM runs
WHERE runs.test_id = $1::uuid 
ORDER by runs.started_at desc
LIMIT $2
`

type UIRunsSummaryParams struct {
	TestID uuid.NullUUID
	Limit  int32
}

type UIRunsSummaryRow struct {
	ID              uuid.UUID
	TestRunConfigID uuid.UUID
	RunnerID        uuid.NullUUID
	Result          NullRunResult
	ScheduledAt     sql.NullTime
	StartedAt       sql.NullTime
	FinishedAt      sql.NullTime
}

func (q *Queries) UIRunsSummary(ctx context.Context, db DBTX, arg UIRunsSummaryParams) ([]UIRunsSummaryRow, error) {
	rows, err := db.Query(ctx, uIRunsSummary, arg.TestID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UIRunsSummaryRow
	for rows.Next() {
		var i UIRunsSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.TestRunConfigID,
			&i.RunnerID,
			&i.Result,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uITestResults = `-- name: UITestResults :many
SELECT test_id,array_agg(result) AS results FROM runs where test_id is not null GROUP BY test_id
`

type UITestResultsRow struct {
	TestID  uuid.UUID
	Results interface{}
}

func (q *Queries) UITestResults(ctx context.Context, db DBTX) ([]UITestResultsRow, error) {
	rows, err := db.Query(ctx, uITestResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UITestResultsRow
	for rows.Next() {
		var i UITestResultsRow
		if err := rows.Scan(&i.TestID, &i.Results); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uITestsByLabels = `-- name: UITestsByLabels :many
SELECT labels, array_agg(tests.id) AS tests FROM tests WHERE labels IN (SELECT DISTINCT(labels) FROM tests) GROUP BY labels
`

type UITestsByLabelsRow struct {
	Labels pgtype.JSONB
	Tests  interface{}
}

func (q *Queries) UITestsByLabels(ctx context.Context, db DBTX) ([]UITestsByLabelsRow, error) {
	rows, err := db.Query(ctx, uITestsByLabels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UITestsByLabelsRow
	for rows.Next() {
		var i UITestsByLabelsRow
		if err := rows.Scan(&i.Labels, &i.Tests); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
